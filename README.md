<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# dagger

```go
import "github.com/autom8ter/dagger/v3"
```

Package dagger is a collection of generic, concurrency safe datastructures including a Directed Acyclic Graph and others. Datastructures are implemented using generics in Go 1.18.

Supported Datastructures:

DAG: thread safe directed acyclic graph

Queue: unbounded thread safe fifo queue

Stack: unbounded thread safe lifo stack

BoundedQueue: bounded thread safe fifo queue with a fixed capacity

PriorityQueue: thread safe priority queue

HashMap: thread safe hashmap

Set: thread safe set

ChannelGroup: thread safe group of channels for broadcasting 1 value to N channels

MultiContext: thread safe context for coordinating the cancellation of multiple contexts

## Index

- [func UniqueID\(prefix string\) string](<#UniqueID>)
- [type Borrower](<#Borrower>)
  - [func NewBorrower\[T any\]\(value T\) \*Borrower\[T\]](<#NewBorrower>)
  - [func \(b \*Borrower\[T\]\) Borrow\(\) \*T](<#Borrower[T].Borrow>)
  - [func \(b \*Borrower\[T\]\) BorrowContext\(ctx context.Context\) \(\*T, error\)](<#Borrower[T].BorrowContext>)
  - [func \(b \*Borrower\[T\]\) Close\(\) error](<#Borrower[T].Close>)
  - [func \(b \*Borrower\[T\]\) Do\(fn func\(\*T\)\) error](<#Borrower[T].Do>)
  - [func \(b \*Borrower\[T\]\) Return\(obj \*T\) error](<#Borrower[T].Return>)
  - [func \(b \*Borrower\[T\]\) TryBorrow\(\) \(\*T, bool\)](<#Borrower[T].TryBorrow>)
  - [func \(b \*Borrower\[T\]\) Value\(\) T](<#Borrower[T].Value>)
- [type BoundedQueue](<#BoundedQueue>)
  - [func NewBoundedQueue\[T any\]\(maxSize int\) \*BoundedQueue\[T\]](<#NewBoundedQueue>)
  - [func \(q \*BoundedQueue\[T\]\) Close\(\)](<#BoundedQueue[T].Close>)
  - [func \(q \*BoundedQueue\[T\]\) Len\(\) int](<#BoundedQueue[T].Len>)
  - [func \(q \*BoundedQueue\[T\]\) Pop\(\) \(T, bool\)](<#BoundedQueue[T].Pop>)
  - [func \(q \*BoundedQueue\[T\]\) Push\(val T\)](<#BoundedQueue[T].Push>)
  - [func \(q \*BoundedQueue\[T\]\) Range\(fn func\(element T\) bool\)](<#BoundedQueue[T].Range>)
  - [func \(q \*BoundedQueue\[T\]\) RangeUntil\(fn func\(element T\) bool, done chan struct\{\}\)](<#BoundedQueue[T].RangeUntil>)
- [type ChannelGroup](<#ChannelGroup>)
  - [func NewChannelGroup\[T any\]\(ctx context.Context\) \*ChannelGroup\[T\]](<#NewChannelGroup>)
  - [func \(b \*ChannelGroup\[T\]\) Channel\(ctx context.Context\) \<\-chan T](<#ChannelGroup[T].Channel>)
  - [func \(b \*ChannelGroup\[T\]\) Close\(\)](<#ChannelGroup[T].Close>)
  - [func \(c \*ChannelGroup\[T\]\) Len\(\) int](<#ChannelGroup[T].Len>)
  - [func \(b \*ChannelGroup\[T\]\) Send\(ctx context.Context, val T\)](<#ChannelGroup[T].Send>)
- [type DAG](<#DAG>)
  - [func NewDAG\[T any\]\(opts ...DagOpt\) \(\*DAG\[T\], error\)](<#NewDAG>)
  - [func \(g \*DAG\[T\]\) Acyclic\(\) bool](<#DAG[T].Acyclic>)
  - [func \(g \*DAG\[T\]\) BFS\(ctx context.Context, reverse bool, start \*GraphNode\[T\], search GraphSearchFunc\[T\]\) error](<#DAG[T].BFS>)
  - [func \(g \*DAG\[T\]\) DFS\(ctx context.Context, reverse bool, start \*GraphNode\[T\], fn GraphSearchFunc\[T\]\) error](<#DAG[T].DFS>)
  - [func \(g \*DAG\[T\]\) GetEdge\(id string\) \(\*GraphEdge\[T\], bool\)](<#DAG[T].GetEdge>)
  - [func \(g \*DAG\[T\]\) GetEdges\(\) \[\]\*GraphEdge\[T\]](<#DAG[T].GetEdges>)
  - [func \(g \*DAG\[T\]\) GetNode\(id string\) \(\*GraphNode\[T\], bool\)](<#DAG[T].GetNode>)
  - [func \(g \*DAG\[T\]\) GetNodes\(\) \[\]\*GraphNode\[T\]](<#DAG[T].GetNodes>)
  - [func \(g \*DAG\[T\]\) GraphViz\(\) \(image.Image, error\)](<#DAG[T].GraphViz>)
  - [func \(g \*DAG\[T\]\) HasEdge\(id string\) bool](<#DAG[T].HasEdge>)
  - [func \(g \*DAG\[T\]\) HasNode\(id string\) bool](<#DAG[T].HasNode>)
  - [func \(g \*DAG\[T\]\) RangeEdges\(fn func\(e \*GraphEdge\[T\]\) bool\)](<#DAG[T].RangeEdges>)
  - [func \(g \*DAG\[T\]\) RangeNodes\(fn func\(n \*GraphNode\[T\]\) bool\)](<#DAG[T].RangeNodes>)
  - [func \(g \*DAG\[T\]\) SetNode\(id string, node T, metadata map\[string\]string\) \*GraphNode\[T\]](<#DAG[T].SetNode>)
  - [func \(g \*DAG\[T\]\) Size\(\) \(int, int\)](<#DAG[T].Size>)
  - [func \(g \*DAG\[T\]\) TopologicalSort\(reverse bool\) \(\[\]\*GraphNode\[T\], error\)](<#DAG[T].TopologicalSort>)
- [type DagOpt](<#DagOpt>)
  - [func WithVizualization\(\) DagOpt](<#WithVizualization>)
- [type GraphEdge](<#GraphEdge>)
  - [func \(n \*GraphEdge\[T\]\) From\(\) \*GraphNode\[T\]](<#GraphEdge[T].From>)
  - [func \(n \*GraphEdge\[T\]\) ID\(\) string](<#GraphEdge[T].ID>)
  - [func \(n \*GraphEdge\[T\]\) Metadata\(\) map\[string\]string](<#GraphEdge[T].Metadata>)
  - [func \(n \*GraphEdge\[T\]\) Relationship\(\) string](<#GraphEdge[T].Relationship>)
  - [func \(n \*GraphEdge\[T\]\) SetMetadata\(metadata map\[string\]string\)](<#GraphEdge[T].SetMetadata>)
  - [func \(n \*GraphEdge\[T\]\) To\(\) \*GraphNode\[T\]](<#GraphEdge[T].To>)
- [type GraphNode](<#GraphNode>)
  - [func \(n \*GraphNode\[T\]\) Ancestors\(fn func\(node \*GraphNode\[T\]\) bool\)](<#GraphNode[T].Ancestors>)
  - [func \(n \*GraphNode\[T\]\) BFS\(ctx context.Context, reverse bool, fn GraphSearchFunc\[T\]\) error](<#GraphNode[T].BFS>)
  - [func \(n \*GraphNode\[T\]\) DFS\(ctx context.Context, reverse bool, fn GraphSearchFunc\[T\]\) error](<#GraphNode[T].DFS>)
  - [func \(n \*GraphNode\[T\]\) Descendants\(fn func\(node \*GraphNode\[T\]\) bool\)](<#GraphNode[T].Descendants>)
  - [func \(n \*GraphNode\[T\]\) EdgesFrom\(relationship string, fn func\(e \*GraphEdge\[T\]\) bool\)](<#GraphNode[T].EdgesFrom>)
  - [func \(n \*GraphNode\[T\]\) EdgesTo\(relationship string, fn func\(e \*GraphEdge\[T\]\) bool\)](<#GraphNode[T].EdgesTo>)
  - [func \(n \*GraphNode\[T\]\) Graph\(\) \*DAG\[T\]](<#GraphNode[T].Graph>)
  - [func \(n \*GraphNode\[T\]\) ID\(\) string](<#GraphNode[T].ID>)
  - [func \(n \*GraphNode\[T\]\) IsConnectedTo\(node \*GraphNode\[T\]\) bool](<#GraphNode[T].IsConnectedTo>)
  - [func \(n \*GraphNode\[T\]\) Metadata\(\) map\[string\]string](<#GraphNode[T].Metadata>)
  - [func \(n \*GraphNode\[T\]\) Remove\(\) error](<#GraphNode[T].Remove>)
  - [func \(n \*GraphNode\[T\]\) RemoveEdge\(edgeID string\)](<#GraphNode[T].RemoveEdge>)
  - [func \(n \*GraphNode\[T\]\) SetEdge\(toNode \*GraphNode\[T\], relationship string, metadata map\[string\]string\) \(\*GraphEdge\[T\], error\)](<#GraphNode[T].SetEdge>)
  - [func \(n \*GraphNode\[T\]\) SetMetadata\(metadata map\[string\]string\)](<#GraphNode[T].SetMetadata>)
  - [func \(n \*GraphNode\[T\]\) SetValue\(value T\)](<#GraphNode[T].SetValue>)
  - [func \(n \*GraphNode\[T\]\) String\(\) string](<#GraphNode[T].String>)
  - [func \(n \*GraphNode\[T\]\) Value\(\) T](<#GraphNode[T].Value>)
- [type GraphSearchFunc](<#GraphSearchFunc>)
- [type HashMap](<#HashMap>)
  - [func NewHashMap\[T any\]\(\) \*HashMap\[T\]](<#NewHashMap>)
  - [func \(n \*HashMap\[T\]\) Clear\(\)](<#HashMap[T].Clear>)
  - [func \(n \*HashMap\[T\]\) Delete\(key string\)](<#HashMap[T].Delete>)
  - [func \(n \*HashMap\[T\]\) Exists\(key string\) bool](<#HashMap[T].Exists>)
  - [func \(n \*HashMap\[T\]\) Filter\(f func\(id string, node T\) bool\) \*HashMap\[T\]](<#HashMap[T].Filter>)
  - [func \(n \*HashMap\[T\]\) Get\(key string\) \(T, bool\)](<#HashMap[T].Get>)
  - [func \(n \*HashMap\[T\]\) Keys\(\) \[\]string](<#HashMap[T].Keys>)
  - [func \(n \*HashMap\[T\]\) Len\(\) int](<#HashMap[T].Len>)
  - [func \(n \*HashMap\[T\]\) Map\(\) map\[string\]T](<#HashMap[T].Map>)
  - [func \(n \*HashMap\[T\]\) Range\(f func\(id string, node T\) bool\)](<#HashMap[T].Range>)
  - [func \(n \*HashMap\[T\]\) Set\(key string, value T\)](<#HashMap[T].Set>)
  - [func \(n \*HashMap\[T\]\) Values\(\) \[\]T](<#HashMap[T].Values>)
- [type MultiContext](<#MultiContext>)
  - [func NewMultiContext\(ctx context.Context\) \*MultiContext](<#NewMultiContext>)
  - [func \(m \*MultiContext\) Cancel\(\)](<#MultiContext.Cancel>)
  - [func \(m \*MultiContext\) WithContext\(ctx context.Context\) context.Context](<#MultiContext.WithContext>)
- [type PriorityQueue](<#PriorityQueue>)
  - [func NewPriorityQueue\[T any\]\(\) \*PriorityQueue\[T\]](<#NewPriorityQueue>)
  - [func \(q \*PriorityQueue\[T\]\) Len\(\) int](<#PriorityQueue[T].Len>)
  - [func \(q \*PriorityQueue\[T\]\) Peek\(\) \(T, bool\)](<#PriorityQueue[T].Peek>)
  - [func \(q \*PriorityQueue\[T\]\) Pop\(\) \(T, bool\)](<#PriorityQueue[T].Pop>)
  - [func \(q \*PriorityQueue\[T\]\) Push\(item T, weight float64\)](<#PriorityQueue[T].Push>)
  - [func \(q \*PriorityQueue\[T\]\) UpdatePriority\(value T, priority float64\)](<#PriorityQueue[T].UpdatePriority>)
- [type Queue](<#Queue>)
  - [func NewQueue\[T any\]\(\) \*Queue\[T\]](<#NewQueue>)
  - [func \(s \*Queue\[T\]\) Len\(\) int](<#Queue[T].Len>)
  - [func \(s \*Queue\[T\]\) Peek\(\) \(T, bool\)](<#Queue[T].Peek>)
  - [func \(s \*Queue\[T\]\) Pop\(\) \(T, bool\)](<#Queue[T].Pop>)
  - [func \(s \*Queue\[T\]\) Push\(f T\)](<#Queue[T].Push>)
  - [func \(q \*Queue\[T\]\) Range\(fn func\(element T\) bool\)](<#Queue[T].Range>)
  - [func \(q \*Queue\[T\]\) RangeUntil\(fn func\(element T\) bool, done chan struct\{\}\)](<#Queue[T].RangeUntil>)
- [type Set](<#Set>)
  - [func NewSet\[T comparable\]\(\) \*Set\[T\]](<#NewSet>)
  - [func \(s \*Set\[T\]\) Add\(val T\)](<#Set[T].Add>)
  - [func \(s \*Set\[T\]\) Contains\(val T\) bool](<#Set[T].Contains>)
  - [func \(s \*Set\[T\]\) Len\(\) int](<#Set[T].Len>)
  - [func \(s \*Set\[T\]\) Range\(fn func\(element T\) bool\)](<#Set[T].Range>)
  - [func \(s \*Set\[T\]\) Remove\(val T\)](<#Set[T].Remove>)
  - [func \(s \*Set\[T\]\) Sort\(lessFunc func\(i T, j T\) bool\) \[\]T](<#Set[T].Sort>)
  - [func \(s \*Set\[T\]\) Values\(\) \[\]T](<#Set[T].Values>)
- [type Stack](<#Stack>)
  - [func NewStack\[T any\]\(\) \*Stack\[T\]](<#NewStack>)
  - [func \(s \*Stack\[T\]\) Clear\(\)](<#Stack[T].Clear>)
  - [func \(s \*Stack\[T\]\) Len\(\) int](<#Stack[T].Len>)
  - [func \(s \*Stack\[T\]\) Peek\(\) \(T, bool\)](<#Stack[T].Peek>)
  - [func \(s \*Stack\[T\]\) Pop\(\) \(T, bool\)](<#Stack[T].Pop>)
  - [func \(s \*Stack\[T\]\) Push\(f T\)](<#Stack[T].Push>)
  - [func \(s \*Stack\[T\]\) Range\(fn func\(element T\) bool\)](<#Stack[T].Range>)
  - [func \(s \*Stack\[T\]\) RangeUntil\(fn func\(element T\) bool, done chan struct\{\}\)](<#Stack[T].RangeUntil>)
  - [func \(s \*Stack\[T\]\) Sort\(lessFunc func\(i T, j T\) bool\) \[\]T](<#Stack[T].Sort>)
  - [func \(s \*Stack\[T\]\) Values\(\) \[\]T](<#Stack[T].Values>)


<a name="UniqueID"></a>
## func [UniqueID](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L47>)

```go
func UniqueID(prefix string) string
```

UniqueID returns a unique identifier with the given prefix

<a name="Borrower"></a>
## type [Borrower](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1410-L1416>)

Borrower is a thread\-safe object that can be borrowed and returned.

```go
type Borrower[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewBorrower"></a>
### func [NewBorrower](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1419>)

```go
func NewBorrower[T any](value T) *Borrower[T]
```

NewBorrower returns a new Borrower with the provided value.

<a name="Borrower[T].Borrow"></a>
### func \(\*Borrower\[T\]\) [Borrow](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1431>)

```go
func (b *Borrower[T]) Borrow() *T
```

Borrow returns the value of the Borrower. If the value is not available, it will block until it is.

<a name="Borrower[T].BorrowContext"></a>
### func \(\*Borrower\[T\]\) [BorrowContext](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1449>)

```go
func (b *Borrower[T]) BorrowContext(ctx context.Context) (*T, error)
```

BorrowContext returns the value of the Borrower. If the value is not available, it will block until it is or the context is canceled.

<a name="Borrower[T].Close"></a>
### func \(\*Borrower\[T\]\) [Close](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1496>)

```go
func (b *Borrower[T]) Close() error
```

Close closes the Borrower and prevents it from being borrowed again. If the Borrower is still borrowed, it will return an error. Close is idempotent.

<a name="Borrower[T].Do"></a>
### func \(\*Borrower\[T\]\) [Do](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1488>)

```go
func (b *Borrower[T]) Do(fn func(*T)) error
```

Do borrows the value, calls the provided function, and returns the value.

<a name="Borrower[T].Return"></a>
### func \(\*Borrower\[T\]\) [Return](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1466>)

```go
func (b *Borrower[T]) Return(obj *T) error
```

Return returns the value to the Borrower so it can be borrowed again. If the value is not a pointer to the value that was borrowed, it will return an error. If the value has already been returned, it will return an error.

<a name="Borrower[T].TryBorrow"></a>
### func \(\*Borrower\[T\]\) [TryBorrow](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1436>)

```go
func (b *Borrower[T]) TryBorrow() (*T, bool)
```

TryBorrow returns the value of the Borrower if it is available. If the value is not available, it will return false.

<a name="Borrower[T].Value"></a>
### func \(\*Borrower\[T\]\) [Value](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1481>)

```go
func (b *Borrower[T]) Value() T
```

Value returns the value of the Borrower. This is a non\-blocking operation since the value is not borrowed\(non\-pointer\).

<a name="BoundedQueue"></a>
## type [BoundedQueue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L944-L947>)

BoundedQueue is a basic FIFO BoundedQueue based on a buffered channel

```go
type BoundedQueue[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewBoundedQueue"></a>
### func [NewBoundedQueue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L951>)

```go
func NewBoundedQueue[T any](maxSize int) *BoundedQueue[T]
```

NewBoundedQueue returns a new BoundedQueue with the given max size. When the max size is reached, the queue will block until a value is removed. If maxSize is 0, the queue will always block until a value is removed. The BoundedQueue is concurrent\-safe.

<a name="BoundedQueue[T].Close"></a>
### func \(\*BoundedQueue\[T\]\) [Close](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L994>)

```go
func (q *BoundedQueue[T]) Close()
```

Close closes the BoundedQueue channel.

<a name="BoundedQueue[T].Len"></a>
### func \(\*BoundedQueue\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1014>)

```go
func (q *BoundedQueue[T]) Len() int
```

Len returns the number of elements in the BoundedQueue.

<a name="BoundedQueue[T].Pop"></a>
### func \(\*BoundedQueue\[T\]\) [Pop](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1006>)

```go
func (q *BoundedQueue[T]) Pop() (T, bool)
```

Pop removes and returns an element from the beginning of the BoundedQueue.

<a name="BoundedQueue[T].Push"></a>
### func \(\*BoundedQueue\[T\]\) [Push](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1001>)

```go
func (q *BoundedQueue[T]) Push(val T)
```

Push adds an element to the end of the BoundedQueue.

<a name="BoundedQueue[T].Range"></a>
### func \(\*BoundedQueue\[T\]\) [Range](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L957>)

```go
func (q *BoundedQueue[T]) Range(fn func(element T) bool)
```

Range executes a provided function once for each BoundedQueue element until it returns false.

<a name="BoundedQueue[T].RangeUntil"></a>
### func \(\*BoundedQueue\[T\]\) [RangeUntil](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L977>)

```go
func (q *BoundedQueue[T]) RangeUntil(fn func(element T) bool, done chan struct{})
```

RangeUntil executes a provided function once for each BoundedQueue element until it returns false or a value is sent to the done channel. Use this function when you want to continuously process items from the queue until a done signal is received.

<a name="ChannelGroup"></a>
## type [ChannelGroup](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1281-L1285>)

ChannelGroup is a thread\-safe group of channels. It is useful for broadcasting a value to multiple channels at once.

```go
type ChannelGroup[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewChannelGroup"></a>
### func [NewChannelGroup](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1295>)

```go
func NewChannelGroup[T any](ctx context.Context) *ChannelGroup[T]
```

NewChannelGroup returns a new ChannelGroup. The context is used to cancel all subscribers when the context is canceled. A channel group is useful for broadcasting a value to multiple subscribers.

<a name="ChannelGroup[T].Channel"></a>
### func \(\*ChannelGroup\[T\]\) [Channel](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1328>)

```go
func (b *ChannelGroup[T]) Channel(ctx context.Context) <-chan T
```

Channel returns a channel that will receive values from broadcasted values. The channel will be closed when the context is canceled. This is a non\-blocking operation.

<a name="ChannelGroup[T].Close"></a>
### func \(\*ChannelGroup\[T\]\) [Close](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1356>)

```go
func (b *ChannelGroup[T]) Close()
```

Close blocks until all subscribers have been removed and then closes the broadcast.

<a name="ChannelGroup[T].Len"></a>
### func \(\*ChannelGroup\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1351>)

```go
func (c *ChannelGroup[T]) Len() int
```

Len returns the number of subscribers.

<a name="ChannelGroup[T].Send"></a>
### func \(\*ChannelGroup\[T\]\) [Send](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1304>)

```go
func (b *ChannelGroup[T]) Send(ctx context.Context, val T)
```

Send sends a value to all channels in the group.

<a name="DAG"></a>
## type [DAG](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L339-L346>)

DAG is a concurrency safe, mutable, in\-memory directed graph

```go
type DAG[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewDAG"></a>
### func [NewDAG](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L363>)

```go
func NewDAG[T any](opts ...DagOpt) (*DAG[T], error)
```

NewDAG creates a new Directed Acyclic Graph instance

<a name="DAG[T].Acyclic"></a>
### func \(\*DAG\[T\]\) [Acyclic](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L668>)

```go
func (g *DAG[T]) Acyclic() bool
```

Acyclic returns true if the graph contains no cycles.

<a name="DAG[T].BFS"></a>
### func \(\*DAG\[T\]\) [BFS](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L484>)

```go
func (g *DAG[T]) BFS(ctx context.Context, reverse bool, start *GraphNode[T], search GraphSearchFunc[T]) error
```

BFS executes a depth first search on the graph starting from the current node. The reverse parameter determines whether the search is reversed or not. The fn parameter is a function that is called on each node in the graph. If the function returns false, the search is stopped.

<a name="DAG[T].DFS"></a>
### func \(\*DAG\[T\]\) [DFS](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L511>)

```go
func (g *DAG[T]) DFS(ctx context.Context, reverse bool, start *GraphNode[T], fn GraphSearchFunc[T]) error
```

DFS executes a depth first search on the graph starting from the current node. The reverse parameter determines whether the search is reversed or not. The fn parameter is a function that is called on each node in the graph. If the function returns false, the search is stopped.

<a name="DAG[T].GetEdge"></a>
### func \(\*DAG\[T\]\) [GetEdge](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L459>)

```go
func (g *DAG[T]) GetEdge(id string) (*GraphEdge[T], bool)
```

GetEdge returns the edge with the given id

<a name="DAG[T].GetEdges"></a>
### func \(\*DAG\[T\]\) [GetEdges](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L449>)

```go
func (g *DAG[T]) GetEdges() []*GraphEdge[T]
```

GetEdges returns all edges in the graph

<a name="DAG[T].GetNode"></a>
### func \(\*DAG\[T\]\) [GetNode](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L428>)

```go
func (g *DAG[T]) GetNode(id string) (*GraphNode[T], bool)
```

GetNode returns the node with the given id

<a name="DAG[T].GetNodes"></a>
### func \(\*DAG\[T\]\) [GetNodes](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L439>)

```go
func (g *DAG[T]) GetNodes() []*GraphNode[T]
```

GetNodes returns all nodes in the graph

<a name="DAG[T].GraphViz"></a>
### func \(\*DAG\[T\]\) [GraphViz](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L753>)

```go
func (g *DAG[T]) GraphViz() (image.Image, error)
```

GraphViz returns a graphviz image

<a name="DAG[T].HasEdge"></a>
### func \(\*DAG\[T\]\) [HasEdge](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L422>)

```go
func (g *DAG[T]) HasEdge(id string) bool
```

HasEdge returns true if the edge with the given id exists in the graph

<a name="DAG[T].HasNode"></a>
### func \(\*DAG\[T\]\) [HasNode](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L416>)

```go
func (g *DAG[T]) HasNode(id string) bool
```

HasNode returns true if the node with the given id exists in the graph

<a name="DAG[T].RangeEdges"></a>
### func \(\*DAG\[T\]\) [RangeEdges](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L465>)

```go
func (g *DAG[T]) RangeEdges(fn func(e *GraphEdge[T]) bool)
```

RangeEdges iterates over all edges in the graph

<a name="DAG[T].RangeNodes"></a>
### func \(\*DAG\[T\]\) [RangeNodes](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L472>)

```go
func (g *DAG[T]) RangeNodes(fn func(n *GraphNode[T]) bool)
```

RangeNodes iterates over all nodes in the graph

<a name="DAG[T].SetNode"></a>
### func \(\*DAG\[T\]\) [SetNode](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L383>)

```go
func (g *DAG[T]) SetNode(id string, node T, metadata map[string]string) *GraphNode[T]
```

SetNode sets a node in the graph \- it will use the node's ID as the key and overwrite any existing node with the same ID

<a name="DAG[T].Size"></a>
### func \(\*DAG\[T\]\) [Size](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L434>)

```go
func (g *DAG[T]) Size() (int, int)
```

Size returns the number of nodes and edges in the graph

<a name="DAG[T].TopologicalSort"></a>
### func \(\*DAG\[T\]\) [TopologicalSort](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L704>)

```go
func (g *DAG[T]) TopologicalSort(reverse bool) ([]*GraphNode[T], error)
```



<a name="DagOpt"></a>
## type [DagOpt](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L353>)

DagOpt is an option for configuring a DAG

```go
type DagOpt func(*dagOpts)
```

<a name="WithVizualization"></a>
### func [WithVizualization](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L356>)

```go
func WithVizualization() DagOpt
```

WithVizualization enables graphviz visualization on the DAG

<a name="GraphEdge"></a>
## type [GraphEdge](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L60-L72>)

GraphEdge is a relationship between two nodes

```go
type GraphEdge[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="GraphEdge[T].From"></a>
### func \(\*GraphEdge\[T\]\) [From](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L85>)

```go
func (n *GraphEdge[T]) From() *GraphNode[T]
```

From returns the from node of the edge

<a name="GraphEdge[T].ID"></a>
### func \(\*GraphEdge\[T\]\) [ID](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L75>)

```go
func (n *GraphEdge[T]) ID() string
```

ID returns the unique identifier of the node

<a name="GraphEdge[T].Metadata"></a>
### func \(\*GraphEdge\[T\]\) [Metadata](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L80>)

```go
func (n *GraphEdge[T]) Metadata() map[string]string
```

Metadata returns the metadata of the node

<a name="GraphEdge[T].Relationship"></a>
### func \(\*GraphEdge\[T\]\) [Relationship](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L95>)

```go
func (n *GraphEdge[T]) Relationship() string
```

Relationship returns the relationship between the two nodes

<a name="GraphEdge[T].SetMetadata"></a>
### func \(\*GraphEdge\[T\]\) [SetMetadata](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L100>)

```go
func (n *GraphEdge[T]) SetMetadata(metadata map[string]string)
```

SetMetadata sets the metadata of the node

<a name="GraphEdge[T].To"></a>
### func \(\*GraphEdge\[T\]\) [To](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L90>)

```go
func (n *GraphEdge[T]) To() *GraphNode[T]
```

To returns the to node of the edge

<a name="GraphNode"></a>
## type [GraphNode](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L107-L115>)

GraphNode is a node in the graph. It can be connected to other nodes via edges.

```go
type GraphNode[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="GraphNode[T].Ancestors"></a>
### func \(\*GraphNode\[T\]\) [Ancestors](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L270>)

```go
func (n *GraphNode[T]) Ancestors(fn func(node *GraphNode[T]) bool)
```

Ancestors returns the ancestors of the current node

<a name="GraphNode[T].BFS"></a>
### func \(\*GraphNode\[T\]\) [BFS](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L150>)

```go
func (n *GraphNode[T]) BFS(ctx context.Context, reverse bool, fn GraphSearchFunc[T]) error
```

BFS performs a breadth\-first search on the graph starting from the current node

<a name="GraphNode[T].DFS"></a>
### func \(\*GraphNode\[T\]\) [DFS](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L145>)

```go
func (n *GraphNode[T]) DFS(ctx context.Context, reverse bool, fn GraphSearchFunc[T]) error
```

DFS performs a depth\-first search on the graph starting from the current node

<a name="GraphNode[T].Descendants"></a>
### func \(\*GraphNode\[T\]\) [Descendants](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L292>)

```go
func (n *GraphNode[T]) Descendants(fn func(node *GraphNode[T]) bool)
```

Descendants returns the descendants of the current node

<a name="GraphNode[T].EdgesFrom"></a>
### func \(\*GraphNode\[T\]\) [EdgesFrom](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L156>)

```go
func (n *GraphNode[T]) EdgesFrom(relationship string, fn func(e *GraphEdge[T]) bool)
```

EdgesFrom iterates over the edges from the current node to other nodes with the given relationship. If the relationship is empty, all relationships will be iterated over.

<a name="GraphNode[T].EdgesTo"></a>
### func \(\*GraphNode\[T\]\) [EdgesTo](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L169>)

```go
func (n *GraphNode[T]) EdgesTo(relationship string, fn func(e *GraphEdge[T]) bool)
```

EdgesTo iterates over the edges from other nodes to the current node with the given relationship. If the relationship is empty, all relationships will be iterated over.

<a name="GraphNode[T].Graph"></a>
### func \(\*GraphNode\[T\]\) [Graph](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L265>)

```go
func (n *GraphNode[T]) Graph() *DAG[T]
```

DirectedGraph returns the graph the node belongs to

<a name="GraphNode[T].ID"></a>
### func \(\*GraphNode\[T\]\) [ID](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L118>)

```go
func (n *GraphNode[T]) ID() string
```

ID returns the unique identifier of the node

<a name="GraphNode[T].IsConnectedTo"></a>
### func \(\*GraphNode\[T\]\) [IsConnectedTo](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L319>)

```go
func (n *GraphNode[T]) IsConnectedTo(node *GraphNode[T]) bool
```

IsConnectedTo returns true if the current node is connected to the given node in any direction

<a name="GraphNode[T].Metadata"></a>
### func \(\*GraphNode\[T\]\) [Metadata](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L123>)

```go
func (n *GraphNode[T]) Metadata() map[string]string
```

Metadata returns the metadata of the node

<a name="GraphNode[T].Remove"></a>
### func \(\*GraphNode\[T\]\) [Remove](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L248>)

```go
func (n *GraphNode[T]) Remove() error
```

Remove removes the current node from the graph

<a name="GraphNode[T].RemoveEdge"></a>
### func \(\*GraphNode\[T\]\) [RemoveEdge](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L228>)

```go
func (n *GraphNode[T]) RemoveEdge(edgeID string)
```

RemoveEdge removes an edge from the current node by edgeID

<a name="GraphNode[T].SetEdge"></a>
### func \(\*GraphNode\[T\]\) [SetEdge](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L184>)

```go
func (n *GraphNode[T]) SetEdge(toNode *GraphNode[T], relationship string, metadata map[string]string) (*GraphEdge[T], error)
```

SetEdge sets an edge from the current node to the node with the given nodeID. If the nodeID does not exist, an error is returned. If the edgeID is empty, a unique id will be generated. If the metadata is nil, an empty map will be used.

<a name="GraphNode[T].SetMetadata"></a>
### func \(\*GraphNode\[T\]\) [SetMetadata](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L133>)

```go
func (n *GraphNode[T]) SetMetadata(metadata map[string]string)
```

SetMetadata sets the metadata of the node

<a name="GraphNode[T].SetValue"></a>
### func \(\*GraphNode\[T\]\) [SetValue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L140>)

```go
func (n *GraphNode[T]) SetValue(value T)
```

SetValue sets the value of the node

<a name="GraphNode[T].String"></a>
### func \(\*GraphNode\[T\]\) [String](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L314>)

```go
func (n *GraphNode[T]) String() string
```

String returns a string representation of the node

<a name="GraphNode[T].Value"></a>
### func \(\*GraphNode\[T\]\) [Value](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L128>)

```go
func (n *GraphNode[T]) Value() T
```

Value returns the value of the node

<a name="GraphSearchFunc"></a>
## type [GraphSearchFunc](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L479>)

GraphSearchFunc is a function that is called on each node in the graph during a search

```go
type GraphSearchFunc[T any] func(ctx context.Context, relationship string, node *GraphNode[T]) bool
```

<a name="HashMap"></a>
## type [HashMap](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L774-L776>)

HashMap is a thread safe map

```go
type HashMap[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewHashMap"></a>
### func [NewHashMap](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L767>)

```go
func NewHashMap[T any]() *HashMap[T]
```

NewHashMap creates a new generic hash map

<a name="HashMap[T].Clear"></a>
### func \(\*HashMap\[T\]\) [Clear](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L814>)

```go
func (n *HashMap[T]) Clear()
```

Clear clears the map

<a name="HashMap[T].Delete"></a>
### func \(\*HashMap\[T\]\) [Delete](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L803>)

```go
func (n *HashMap[T]) Delete(key string)
```

Delete deletes the key from the map

<a name="HashMap[T].Exists"></a>
### func \(\*HashMap\[T\]\) [Exists](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L808>)

```go
func (n *HashMap[T]) Exists(key string) bool
```

Exists returns true if the key exists in the map

<a name="HashMap[T].Filter"></a>
### func \(\*HashMap\[T\]\) [Filter](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L849>)

```go
func (n *HashMap[T]) Filter(f func(id string, node T) bool) *HashMap[T]
```

Filter returns a new hashmap with the values that return true from the function

<a name="HashMap[T].Get"></a>
### func \(\*HashMap\[T\]\) [Get](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L789>)

```go
func (n *HashMap[T]) Get(key string) (T, bool)
```

Get gets the value from the key

<a name="HashMap[T].Keys"></a>
### func \(\*HashMap\[T\]\) [Keys](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L822>)

```go
func (n *HashMap[T]) Keys() []string
```

Keys returns a copy of the keys in the map as a slice

<a name="HashMap[T].Len"></a>
### func \(\*HashMap\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L779>)

```go
func (n *HashMap[T]) Len() int
```

Len returns the length of the map

<a name="HashMap[T].Map"></a>
### func \(\*HashMap\[T\]\) [Map](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L861>)

```go
func (n *HashMap[T]) Map() map[string]T
```

Map returns a copy of the hashmap as a map\[string\]T

<a name="HashMap[T].Range"></a>
### func \(\*HashMap\[T\]\) [Range](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L842>)

```go
func (n *HashMap[T]) Range(f func(id string, node T) bool)
```

Range ranges over the map with a function until false is returned

<a name="HashMap[T].Set"></a>
### func \(\*HashMap\[T\]\) [Set](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L798>)

```go
func (n *HashMap[T]) Set(key string, value T)
```

Set sets the key to the value

<a name="HashMap[T].Values"></a>
### func \(\*HashMap\[T\]\) [Values](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L832>)

```go
func (n *HashMap[T]) Values() []T
```

Values returns a copy of the values in the map as a slice

<a name="MultiContext"></a>
## type [MultiContext](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1362-L1367>)

MultiContext is a context that can be used to combine contexts with a root context so they can be cancelled together.

```go
type MultiContext struct {
    context.Context
    // contains filtered or unexported fields
}
```

<a name="NewMultiContext"></a>
### func [NewMultiContext](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1370>)

```go
func NewMultiContext(ctx context.Context) *MultiContext
```

NewMultiContext returns a new MultiContext.

<a name="MultiContext.Cancel"></a>
### func \(\*MultiContext\) [Cancel](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1400>)

```go
func (m *MultiContext) Cancel()
```

Cancel cancels all child contexts.

<a name="MultiContext.WithContext"></a>
### func \(\*MultiContext\) [WithContext](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1391>)

```go
func (m *MultiContext) WithContext(ctx context.Context) context.Context
```

WithContext returns a new context that is a child of the root context. This context will be cancelled when the multi context is cancelled.

<a name="PriorityQueue"></a>
## type [PriorityQueue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L877-L880>)

PriorityQueue is a thread safe priority queue

```go
type PriorityQueue[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewPriorityQueue"></a>
### func [NewPriorityQueue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L883>)

```go
func NewPriorityQueue[T any]() *PriorityQueue[T]
```

NewPriorityQueue creates a new priority queue

<a name="PriorityQueue[T].Len"></a>
### func \(\*PriorityQueue\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L905>)

```go
func (q *PriorityQueue[T]) Len() int
```

Len returns the length of the queue

<a name="PriorityQueue[T].Peek"></a>
### func \(\*PriorityQueue\[T\]\) [Peek](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L934>)

```go
func (q *PriorityQueue[T]) Peek() (T, bool)
```

Peek returns the next item in the queue without removing it

<a name="PriorityQueue[T].Pop"></a>
### func \(\*PriorityQueue\[T\]\) [Pop](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L922>)

```go
func (q *PriorityQueue[T]) Pop() (T, bool)
```

Pop pops an item off the queue

<a name="PriorityQueue[T].Push"></a>
### func \(\*PriorityQueue\[T\]\) [Push](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L912>)

```go
func (q *PriorityQueue[T]) Push(item T, weight float64)
```

Push pushes an item onto the queue

<a name="PriorityQueue[T].UpdatePriority"></a>
### func \(\*PriorityQueue\[T\]\) [UpdatePriority](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L890>)

```go
func (q *PriorityQueue[T]) UpdatePriority(value T, priority float64)
```



<a name="Queue"></a>
## type [Queue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1019-L1022>)

Queue is a thread safe non\-blocking queue

```go
type Queue[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewQueue"></a>
### func [NewQueue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1025>)

```go
func NewQueue[T any]() *Queue[T]
```

NewQueue returns a new Queue

<a name="Queue[T].Len"></a>
### func \(\*Queue\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1052>)

```go
func (s *Queue[T]) Len() int
```

Len returns the length of the queue

<a name="Queue[T].Peek"></a>
### func \(\*Queue\[T\]\) [Peek](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1059>)

```go
func (s *Queue[T]) Peek() (T, bool)
```

Peek returns the next item in the queue without removing it

<a name="Queue[T].Pop"></a>
### func \(\*Queue\[T\]\) [Pop](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1038>)

```go
func (s *Queue[T]) Pop() (T, bool)
```

Pop and return top element of Queue. Return false if Queue is empty.

<a name="Queue[T].Push"></a>
### func \(\*Queue\[T\]\) [Push](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1031>)

```go
func (s *Queue[T]) Push(f T)
```

Push a new value onto the Queue

<a name="Queue[T].Range"></a>
### func \(\*Queue\[T\]\) [Range](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1069>)

```go
func (q *Queue[T]) Range(fn func(element T) bool)
```

Range executes a provided function once for each Queue element until it returns false or the Queue is empty.

<a name="Queue[T].RangeUntil"></a>
### func \(\*Queue\[T\]\) [RangeUntil](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1083>)

```go
func (q *Queue[T]) RangeUntil(fn func(element T) bool, done chan struct{})
```

RangeUntil executes a provided function once for each Queue element until it returns false or a value is sent on the done channel. Use this function when you want to continuously process items from the queue until a done signal is received.

<a name="Set"></a>
## type [Set](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1209-L1212>)

Set is a basic thread\-safe Set implementation.

```go
type Set[T comparable] struct {
    // contains filtered or unexported fields
}
```

<a name="NewSet"></a>
### func [NewSet](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1215>)

```go
func NewSet[T comparable]() *Set[T]
```

NewSet returns a new Set with the given initial size.

<a name="Set[T].Add"></a>
### func \(\*Set\[T\]\) [Add](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1221>)

```go
func (s *Set[T]) Add(val T)
```

Add adds an element to the Set.

<a name="Set[T].Contains"></a>
### func \(\*Set\[T\]\) [Contains](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1235>)

```go
func (s *Set[T]) Contains(val T) bool
```

Contains returns true if the Set contains the element.

<a name="Set[T].Len"></a>
### func \(\*Set\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1254>)

```go
func (s *Set[T]) Len() int
```

Len returns the number of elements in the Set.

<a name="Set[T].Range"></a>
### func \(\*Set\[T\]\) [Range](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1243>)

```go
func (s *Set[T]) Range(fn func(element T) bool)
```

Range executes a provided function once for each Set element until it returns false.

<a name="Set[T].Remove"></a>
### func \(\*Set\[T\]\) [Remove](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1228>)

```go
func (s *Set[T]) Remove(val T)
```

Remove removes an element from the Set.

<a name="Set[T].Sort"></a>
### func \(\*Set\[T\]\) [Sort](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1272>)

```go
func (s *Set[T]) Sort(lessFunc func(i T, j T) bool) []T
```

Sort returns the values of the set as an array sorted by the provided less function

<a name="Set[T].Values"></a>
### func \(\*Set\[T\]\) [Values](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1261>)

```go
func (s *Set[T]) Values() []T
```

Values returns the values of the set as an array

<a name="Stack"></a>
## type [Stack](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1107-L1110>)

Stack is a basic LIFO Stack

```go
type Stack[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewStack"></a>
### func [NewStack](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1101>)

```go
func NewStack[T any]() *Stack[T]
```

NewStack returns a new Stack instance

<a name="Stack[T].Clear"></a>
### func \(\*Stack\[T\]\) [Clear](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1153>)

```go
func (s *Stack[T]) Clear()
```

Clear removes all elements from the Stack

<a name="Stack[T].Len"></a>
### func \(\*Stack\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1189>)

```go
func (s *Stack[T]) Len() int
```

Len returns the number of elements in the Stack.

<a name="Stack[T].Peek"></a>
### func \(\*Stack\[T\]\) [Peek](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1196>)

```go
func (s *Stack[T]) Peek() (T, bool)
```

Peek returns the top element of the Stack without removing it. Return false if Stack is empty.

<a name="Stack[T].Pop"></a>
### func \(\*Stack\[T\]\) [Pop](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1139>)

```go
func (s *Stack[T]) Pop() (T, bool)
```

Pop removes and return top element of Stack. Return false if Stack is empty.

<a name="Stack[T].Push"></a>
### func \(\*Stack\[T\]\) [Push](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1132>)

```go
func (s *Stack[T]) Push(f T)
```

Push a new value onto the Stack \(LIFO\)

<a name="Stack[T].Range"></a>
### func \(\*Stack\[T\]\) [Range](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1160>)

```go
func (s *Stack[T]) Range(fn func(element T) bool)
```

Range executes a provided function once for each Stack element until it returns false.

<a name="Stack[T].RangeUntil"></a>
### func \(\*Stack\[T\]\) [RangeUntil](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1114>)

```go
func (s *Stack[T]) RangeUntil(fn func(element T) bool, done chan struct{})
```

RangeUntil executes a provided function once after calling Pop on the stack until the function returns false or a value is sent on the done channel. Use this function when you want to continuously process items from the stack until a done signal is received.

<a name="Stack[T].Sort"></a>
### func \(\*Stack\[T\]\) [Sort](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1180>)

```go
func (s *Stack[T]) Sort(lessFunc func(i T, j T) bool) []T
```

Sort returns the values of the stack as an array sorted by the provided less function

<a name="Stack[T].Values"></a>
### func \(\*Stack\[T\]\) [Values](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1173>)

```go
func (s *Stack[T]) Values() []T
```

Values returns the values of the stack as an array

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
