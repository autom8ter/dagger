<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# dagger

```go
import "github.com/autom8ter/dagger/v3"
```

Package dagger is a collection of generic, concurrency safe datastructures including a Directed Acyclic Graph and others.

```
Datastructures are implemented using generics in Go 1.18.
Supported Datastructures:
DAG: thread safe directed acyclic graph
Queue: unbounded thread safe fifo queue
Stack: unbounded thread safe lifo stack
BoundedQueue: bounded thread safe fifo queue with a fixed capacity
PriorityQueue: thread safe priority queue
HashMap: thread safe hashmap
Set: thread safe set
ChannelGroup: thread safe group of channels for broadcasting 1 value to N channels
MultiContext: thread safe context for coordinating the cancellation of multiple contexts
```

## Index

- [func UniqueID\(prefix string\) string](<#UniqueID>)
- [type BoundedQueue](<#BoundedQueue>)
  - [func NewBoundedQueue\[T any\]\(maxSize int\) \*BoundedQueue\[T\]](<#NewBoundedQueue>)
  - [func \(q \*BoundedQueue\[T\]\) Close\(\)](<#BoundedQueue[T].Close>)
  - [func \(q \*BoundedQueue\[T\]\) Len\(\) int](<#BoundedQueue[T].Len>)
  - [func \(q \*BoundedQueue\[T\]\) Pop\(\) \(T, bool\)](<#BoundedQueue[T].Pop>)
  - [func \(q \*BoundedQueue\[T\]\) Push\(val T\)](<#BoundedQueue[T].Push>)
  - [func \(q \*BoundedQueue\[T\]\) Range\(fn func\(element T\) bool\)](<#BoundedQueue[T].Range>)
  - [func \(q \*BoundedQueue\[T\]\) RangeUntil\(fn func\(element T\) bool, done chan struct\{\}\)](<#BoundedQueue[T].RangeUntil>)
- [type ChannelGroup](<#ChannelGroup>)
  - [func NewChannelGroup\[T any\]\(ctx context.Context\) \*ChannelGroup\[T\]](<#NewChannelGroup>)
  - [func \(b \*ChannelGroup\[T\]\) Channel\(ctx context.Context\) \<\-chan T](<#ChannelGroup[T].Channel>)
  - [func \(b \*ChannelGroup\[T\]\) Close\(\)](<#ChannelGroup[T].Close>)
  - [func \(c \*ChannelGroup\[T\]\) Len\(\) int](<#ChannelGroup[T].Len>)
  - [func \(b \*ChannelGroup\[T\]\) Send\(ctx context.Context, val T\)](<#ChannelGroup[T].Send>)
- [type DAG](<#DAG>)
  - [func NewDAG\[T any\]\(opts ...DagOpt\) \(\*DAG\[T\], error\)](<#NewDAG>)
  - [func \(g \*DAG\[T\]\) Acyclic\(\) bool](<#DAG[T].Acyclic>)
  - [func \(g \*DAG\[T\]\) BFS\(ctx context.Context, reverse bool, start \*GraphNode\[T\], search GraphSearchFunc\[T\]\) error](<#DAG[T].BFS>)
  - [func \(g \*DAG\[T\]\) DFS\(ctx context.Context, reverse bool, start \*GraphNode\[T\], fn GraphSearchFunc\[T\]\) error](<#DAG[T].DFS>)
  - [func \(g \*DAG\[T\]\) GetEdge\(id string\) \(\*GraphEdge\[T\], bool\)](<#DAG[T].GetEdge>)
  - [func \(g \*DAG\[T\]\) GetEdges\(\) \[\]\*GraphEdge\[T\]](<#DAG[T].GetEdges>)
  - [func \(g \*DAG\[T\]\) GetNode\(id string\) \(\*GraphNode\[T\], bool\)](<#DAG[T].GetNode>)
  - [func \(g \*DAG\[T\]\) GetNodes\(\) \[\]\*GraphNode\[T\]](<#DAG[T].GetNodes>)
  - [func \(g \*DAG\[T\]\) GraphViz\(\) \(image.Image, error\)](<#DAG[T].GraphViz>)
  - [func \(g \*DAG\[T\]\) HasEdge\(id string\) bool](<#DAG[T].HasEdge>)
  - [func \(g \*DAG\[T\]\) HasNode\(id string\) bool](<#DAG[T].HasNode>)
  - [func \(g \*DAG\[T\]\) RangeEdges\(fn func\(e \*GraphEdge\[T\]\) bool\)](<#DAG[T].RangeEdges>)
  - [func \(g \*DAG\[T\]\) RangeNodes\(fn func\(n \*GraphNode\[T\]\) bool\)](<#DAG[T].RangeNodes>)
  - [func \(g \*DAG\[T\]\) SetNode\(id string, node T, metadata map\[string\]string\) \*GraphNode\[T\]](<#DAG[T].SetNode>)
  - [func \(g \*DAG\[T\]\) Size\(\) \(int, int\)](<#DAG[T].Size>)
  - [func \(g \*DAG\[T\]\) TopologicalSort\(reverse bool\) \(\[\]\*GraphNode\[T\], error\)](<#DAG[T].TopologicalSort>)
- [type DagOpt](<#DagOpt>)
  - [func WithVizualization\(\) DagOpt](<#WithVizualization>)
- [type GraphEdge](<#GraphEdge>)
- [type GraphNode](<#GraphNode>)
  - [func \(n \*GraphNode\[T\]\) Ancestors\(fn func\(node \*GraphNode\[T\]\) bool\)](<#GraphNode[T].Ancestors>)
  - [func \(n \*GraphNode\[T\]\) BFS\(ctx context.Context, reverse bool, fn GraphSearchFunc\[T\]\) error](<#GraphNode[T].BFS>)
  - [func \(n \*GraphNode\[T\]\) DFS\(ctx context.Context, reverse bool, fn GraphSearchFunc\[T\]\) error](<#GraphNode[T].DFS>)
  - [func \(n \*GraphNode\[T\]\) Descendants\(fn func\(node \*GraphNode\[T\]\) bool\)](<#GraphNode[T].Descendants>)
  - [func \(n \*GraphNode\[T\]\) EdgesFrom\(fn func\(e \*GraphEdge\[T\]\) bool\)](<#GraphNode[T].EdgesFrom>)
  - [func \(n \*GraphNode\[T\]\) EdgesTo\(fn func\(e \*GraphEdge\[T\]\) bool\)](<#GraphNode[T].EdgesTo>)
  - [func \(n \*GraphNode\[T\]\) Graph\(\) \*DAG\[T\]](<#GraphNode[T].Graph>)
  - [func \(n \*GraphNode\[T\]\) ID\(\) string](<#GraphNode[T].ID>)
  - [func \(n \*GraphNode\[T\]\) IsConnectedTo\(node \*GraphNode\[T\]\) bool](<#GraphNode[T].IsConnectedTo>)
  - [func \(n \*GraphNode\[T\]\) Metadata\(\) map\[string\]string](<#GraphNode[T].Metadata>)
  - [func \(n \*GraphNode\[T\]\) Remove\(\) error](<#GraphNode[T].Remove>)
  - [func \(n \*GraphNode\[T\]\) RemoveEdge\(edgeID string\)](<#GraphNode[T].RemoveEdge>)
  - [func \(n \*GraphNode\[T\]\) SetEdge\(toNode \*GraphNode\[T\], relationship string, metadata map\[string\]string\) \(\*GraphEdge\[T\], error\)](<#GraphNode[T].SetEdge>)
  - [func \(n \*GraphNode\[T\]\) SetID\(id string\)](<#GraphNode[T].SetID>)
  - [func \(n \*GraphNode\[T\]\) SetMetadata\(metadata map\[string\]string\)](<#GraphNode[T].SetMetadata>)
  - [func \(n \*GraphNode\[T\]\) SetValue\(value T\)](<#GraphNode[T].SetValue>)
  - [func \(n \*GraphNode\[T\]\) String\(\) string](<#GraphNode[T].String>)
  - [func \(n \*GraphNode\[T\]\) Value\(\) T](<#GraphNode[T].Value>)
- [type GraphSearchFunc](<#GraphSearchFunc>)
- [type HashMap](<#HashMap>)
  - [func NewHashMap\[T any\]\(\) \*HashMap\[T\]](<#NewHashMap>)
  - [func \(n \*HashMap\[T\]\) Clear\(\)](<#HashMap[T].Clear>)
  - [func \(n \*HashMap\[T\]\) Delete\(key string\)](<#HashMap[T].Delete>)
  - [func \(n \*HashMap\[T\]\) Exists\(key string\) bool](<#HashMap[T].Exists>)
  - [func \(n \*HashMap\[T\]\) Get\(key string\) \(T, bool\)](<#HashMap[T].Get>)
  - [func \(n \*HashMap\[T\]\) Keys\(\) \[\]string](<#HashMap[T].Keys>)
  - [func \(n \*HashMap\[T\]\) Len\(\) int](<#HashMap[T].Len>)
  - [func \(n \*HashMap\[T\]\) Range\(f func\(id string, node T\) bool\)](<#HashMap[T].Range>)
  - [func \(n \*HashMap\[T\]\) Set\(key string, value T\)](<#HashMap[T].Set>)
  - [func \(n \*HashMap\[T\]\) Values\(\) \[\]T](<#HashMap[T].Values>)
- [type MultiContext](<#MultiContext>)
  - [func NewMultiContext\(ctx context.Context\) \*MultiContext](<#NewMultiContext>)
  - [func \(m \*MultiContext\) Cancel\(\)](<#MultiContext.Cancel>)
  - [func \(m \*MultiContext\) WithContext\(ctx context.Context\) context.Context](<#MultiContext.WithContext>)
- [type PriorityQueue](<#PriorityQueue>)
  - [func NewPriorityQueue\[T any\]\(\) \*PriorityQueue\[T\]](<#NewPriorityQueue>)
  - [func \(q \*PriorityQueue\[T\]\) Len\(\) int](<#PriorityQueue[T].Len>)
  - [func \(q \*PriorityQueue\[T\]\) Peek\(\) \(T, bool\)](<#PriorityQueue[T].Peek>)
  - [func \(q \*PriorityQueue\[T\]\) Pop\(\) \(T, bool\)](<#PriorityQueue[T].Pop>)
  - [func \(q \*PriorityQueue\[T\]\) Push\(item T, weight float64\)](<#PriorityQueue[T].Push>)
  - [func \(q \*PriorityQueue\[T\]\) UpdatePriority\(value T, priority float64\)](<#PriorityQueue[T].UpdatePriority>)
- [type Queue](<#Queue>)
  - [func NewQueue\[T any\]\(\) \*Queue\[T\]](<#NewQueue>)
  - [func \(s \*Queue\[T\]\) Len\(\) int](<#Queue[T].Len>)
  - [func \(s \*Queue\[T\]\) Peek\(\) \(T, bool\)](<#Queue[T].Peek>)
  - [func \(s \*Queue\[T\]\) Pop\(\) \(T, bool\)](<#Queue[T].Pop>)
  - [func \(s \*Queue\[T\]\) Push\(f T\)](<#Queue[T].Push>)
  - [func \(q \*Queue\[T\]\) Range\(fn func\(element T\) bool\)](<#Queue[T].Range>)
  - [func \(q \*Queue\[T\]\) RangeUntil\(fn func\(element T\) bool, done chan struct\{\}\)](<#Queue[T].RangeUntil>)
- [type Set](<#Set>)
  - [func NewSet\[T comparable\]\(\) \*Set\[T\]](<#NewSet>)
  - [func \(s \*Set\[T\]\) Add\(val T\)](<#Set[T].Add>)
  - [func \(s \*Set\[T\]\) Contains\(val T\) bool](<#Set[T].Contains>)
  - [func \(s \*Set\[T\]\) Len\(\) int](<#Set[T].Len>)
  - [func \(s \*Set\[T\]\) Range\(fn func\(element T\) bool\)](<#Set[T].Range>)
  - [func \(s \*Set\[T\]\) Remove\(val T\)](<#Set[T].Remove>)
  - [func \(s \*Set\[T\]\) Sort\(lessFunc func\(i T, j T\) bool\) \[\]T](<#Set[T].Sort>)
  - [func \(s \*Set\[T\]\) Values\(\) \[\]T](<#Set[T].Values>)
- [type Stack](<#Stack>)
  - [func NewStack\[T any\]\(\) \*Stack\[T\]](<#NewStack>)
  - [func \(s \*Stack\[T\]\) Clear\(\)](<#Stack[T].Clear>)
  - [func \(s \*Stack\[T\]\) Len\(\) int](<#Stack[T].Len>)
  - [func \(s \*Stack\[T\]\) Peek\(\) \(T, bool\)](<#Stack[T].Peek>)
  - [func \(s \*Stack\[T\]\) Pop\(\) \(T, bool\)](<#Stack[T].Pop>)
  - [func \(s \*Stack\[T\]\) Push\(f T\)](<#Stack[T].Push>)
  - [func \(s \*Stack\[T\]\) Range\(fn func\(element T\) bool\)](<#Stack[T].Range>)
  - [func \(s \*Stack\[T\]\) RangeUntil\(fn func\(element T\) bool, done chan struct\{\}\)](<#Stack[T].RangeUntil>)
  - [func \(s \*Stack\[T\]\) Sort\(lessFunc func\(i T, j T\) bool\) \[\]T](<#Stack[T].Sort>)
  - [func \(s \*Stack\[T\]\) Values\(\) \[\]T](<#Stack[T].Values>)


<a name="UniqueID"></a>
## func [UniqueID](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L37>)

```go
func UniqueID(prefix string) string
```

UniqueID returns a unique identifier with the given prefix

<a name="BoundedQueue"></a>
## type [BoundedQueue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L894-L897>)

BoundedQueue is a basic FIFO BoundedQueue based on a buffered channel

```go
type BoundedQueue[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewBoundedQueue"></a>
### func [NewBoundedQueue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L901>)

```go
func NewBoundedQueue[T any](maxSize int) *BoundedQueue[T]
```

NewBoundedQueue returns a new BoundedQueue with the given max size. When the max size is reached, the queue will block until a value is removed. If maxSize is 0, the queue will always block until a value is removed. The BoundedQueue is concurrent\-safe.

<a name="BoundedQueue[T].Close"></a>
### func \(\*BoundedQueue\[T\]\) [Close](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L944>)

```go
func (q *BoundedQueue[T]) Close()
```

Close closes the BoundedQueue channel.

<a name="BoundedQueue[T].Len"></a>
### func \(\*BoundedQueue\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L964>)

```go
func (q *BoundedQueue[T]) Len() int
```

Len returns the number of elements in the BoundedQueue.

<a name="BoundedQueue[T].Pop"></a>
### func \(\*BoundedQueue\[T\]\) [Pop](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L956>)

```go
func (q *BoundedQueue[T]) Pop() (T, bool)
```

Pop removes and returns an element from the beginning of the BoundedQueue.

<a name="BoundedQueue[T].Push"></a>
### func \(\*BoundedQueue\[T\]\) [Push](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L951>)

```go
func (q *BoundedQueue[T]) Push(val T)
```

Push adds an element to the end of the BoundedQueue.

<a name="BoundedQueue[T].Range"></a>
### func \(\*BoundedQueue\[T\]\) [Range](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L907>)

```go
func (q *BoundedQueue[T]) Range(fn func(element T) bool)
```

Range executes a provided function once for each BoundedQueue element until it returns false.

<a name="BoundedQueue[T].RangeUntil"></a>
### func \(\*BoundedQueue\[T\]\) [RangeUntil](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L927>)

```go
func (q *BoundedQueue[T]) RangeUntil(fn func(element T) bool, done chan struct{})
```

RangeUntil executes a provided function once for each BoundedQueue element until it returns false or a value is sent to the done channel. Use this function when you want to continuously process items from the queue until a done signal is received.

<a name="ChannelGroup"></a>
## type [ChannelGroup](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1231-L1235>)

ChannelGroup is a thread\-safe group of channels. It is useful for broadcasting a value to multiple channels at once.

```go
type ChannelGroup[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewChannelGroup"></a>
### func [NewChannelGroup](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1244>)

```go
func NewChannelGroup[T any](ctx context.Context) *ChannelGroup[T]
```

NewChannelGroup returns a new ChannelGroup. The context is used to cancel all subscribers when the context is canceled. A channel group is useful for broadcasting a value to multiple subscribers.

<a name="ChannelGroup[T].Channel"></a>
### func \(\*ChannelGroup\[T\]\) [Channel](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1271>)

```go
func (b *ChannelGroup[T]) Channel(ctx context.Context) <-chan T
```

Channel returns a channel that will receive values from broadcasted values. The channel will be closed when the context is canceled. This is a non\-blocking operation.

<a name="ChannelGroup[T].Close"></a>
### func \(\*ChannelGroup\[T\]\) [Close](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1294>)

```go
func (b *ChannelGroup[T]) Close()
```

Close blocks until all subscribers have been removed and then closes the broadcast.

<a name="ChannelGroup[T].Len"></a>
### func \(\*ChannelGroup\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1289>)

```go
func (c *ChannelGroup[T]) Len() int
```

Len returns the number of subscribers.

<a name="ChannelGroup[T].Send"></a>
### func \(\*ChannelGroup\[T\]\) [Send](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1253>)

```go
func (b *ChannelGroup[T]) Send(ctx context.Context, val T)
```

Send sends a value to all channels in the group.

<a name="DAG"></a>
## type [DAG](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L299-L306>)

DirectedGraph is a concurrency safe, mutable, in\-memory directed graph

```go
type DAG[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewDAG"></a>
### func [NewDAG](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L323>)

```go
func NewDAG[T any](opts ...DagOpt) (*DAG[T], error)
```

NewDAG creates a new Directed Acyclic Graph instance

<a name="DAG[T].Acyclic"></a>
### func \(\*DAG\[T\]\) [Acyclic](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L628>)

```go
func (g *DAG[T]) Acyclic() bool
```

Acyclic returns true if the graph contains no cycles.

<a name="DAG[T].BFS"></a>
### func \(\*DAG\[T\]\) [BFS](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L444>)

```go
func (g *DAG[T]) BFS(ctx context.Context, reverse bool, start *GraphNode[T], search GraphSearchFunc[T]) error
```

BFS executes a depth first search on the graph starting from the current node. The reverse parameter determines whether the search is reversed or not. The fn parameter is a function that is called on each node in the graph. If the function returns false, the search is stopped.

<a name="DAG[T].DFS"></a>
### func \(\*DAG\[T\]\) [DFS](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L471>)

```go
func (g *DAG[T]) DFS(ctx context.Context, reverse bool, start *GraphNode[T], fn GraphSearchFunc[T]) error
```

DFS executes a depth first search on the graph starting from the current node. The reverse parameter determines whether the search is reversed or not. The fn parameter is a function that is called on each node in the graph. If the function returns false, the search is stopped.

<a name="DAG[T].GetEdge"></a>
### func \(\*DAG\[T\]\) [GetEdge](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L419>)

```go
func (g *DAG[T]) GetEdge(id string) (*GraphEdge[T], bool)
```

GetEdge returns the edge with the given id

<a name="DAG[T].GetEdges"></a>
### func \(\*DAG\[T\]\) [GetEdges](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L409>)

```go
func (g *DAG[T]) GetEdges() []*GraphEdge[T]
```

GetEdges returns all edges in the graph

<a name="DAG[T].GetNode"></a>
### func \(\*DAG\[T\]\) [GetNode](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L388>)

```go
func (g *DAG[T]) GetNode(id string) (*GraphNode[T], bool)
```

GetNode returns the node with the given id

<a name="DAG[T].GetNodes"></a>
### func \(\*DAG\[T\]\) [GetNodes](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L399>)

```go
func (g *DAG[T]) GetNodes() []*GraphNode[T]
```

GetNodes returns all nodes in the graph

<a name="DAG[T].GraphViz"></a>
### func \(\*DAG\[T\]\) [GraphViz](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L713>)

```go
func (g *DAG[T]) GraphViz() (image.Image, error)
```

GraphViz returns a graphviz image

<a name="DAG[T].HasEdge"></a>
### func \(\*DAG\[T\]\) [HasEdge](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L382>)

```go
func (g *DAG[T]) HasEdge(id string) bool
```

HasEdge returns true if the edge with the given id exists in the graph

<a name="DAG[T].HasNode"></a>
### func \(\*DAG\[T\]\) [HasNode](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L376>)

```go
func (g *DAG[T]) HasNode(id string) bool
```

HasNode returns true if the node with the given id exists in the graph

<a name="DAG[T].RangeEdges"></a>
### func \(\*DAG\[T\]\) [RangeEdges](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L425>)

```go
func (g *DAG[T]) RangeEdges(fn func(e *GraphEdge[T]) bool)
```

RangeEdges iterates over all edges in the graph

<a name="DAG[T].RangeNodes"></a>
### func \(\*DAG\[T\]\) [RangeNodes](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L432>)

```go
func (g *DAG[T]) RangeNodes(fn func(n *GraphNode[T]) bool)
```

RangeNodes iterates over all nodes in the graph

<a name="DAG[T].SetNode"></a>
### func \(\*DAG\[T\]\) [SetNode](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L343>)

```go
func (g *DAG[T]) SetNode(id string, node T, metadata map[string]string) *GraphNode[T]
```

SetNode sets a node in the graph \- it will use the node's ID as the key and overwrite any existing node with the same ID

<a name="DAG[T].Size"></a>
### func \(\*DAG\[T\]\) [Size](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L394>)

```go
func (g *DAG[T]) Size() (int, int)
```

Size returns the number of nodes and edges in the graph

<a name="DAG[T].TopologicalSort"></a>
### func \(\*DAG\[T\]\) [TopologicalSort](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L664>)

```go
func (g *DAG[T]) TopologicalSort(reverse bool) ([]*GraphNode[T], error)
```



<a name="DagOpt"></a>
## type [DagOpt](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L313>)

DagOpt is an option for configuring a DAG

```go
type DagOpt func(*dagOpts)
```

<a name="WithVizualization"></a>
### func [WithVizualization](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L316>)

```go
func WithVizualization() DagOpt
```

WithVizualization enables graphviz visualization on the DAG

<a name="GraphEdge"></a>
## type [GraphEdge](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L50-L62>)

GraphEdge is a relationship between two nodes

```go
type GraphEdge[T any] struct {
    // ID is the unique identifier of the edge
    ID  string `json:"id"`
    // Metadata is the metadata of the edge
    Metadata map[string]string `json:"metadata"`
    // From returns the root node of the edge
    From *GraphNode[T] `json:"from"`
    // To returns the target node of the edge
    To  *GraphNode[T] `json:"to"`
    // Relationship is the relationship between the two nodes
    Relationship string `json:"relationship"`
    // contains filtered or unexported fields
}
```

<a name="GraphNode"></a>
## type [GraphNode](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L65-L73>)

GraphNode is a node in the graph. It can be connected to other nodes via edges.

```go
type GraphNode[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="GraphNode[T].Ancestors"></a>
### func \(\*GraphNode\[T\]\) [Ancestors](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L223>)

```go
func (n *GraphNode[T]) Ancestors(fn func(node *GraphNode[T]) bool)
```

Ancestors returns the ancestors of the current node

<a name="GraphNode[T].BFS"></a>
### func \(\*GraphNode\[T\]\) [BFS](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L111>)

```go
func (n *GraphNode[T]) BFS(ctx context.Context, reverse bool, fn GraphSearchFunc[T]) error
```

BFS performs a breadth\-first search on the graph starting from the current node

<a name="GraphNode[T].DFS"></a>
### func \(\*GraphNode\[T\]\) [DFS](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L106>)

```go
func (n *GraphNode[T]) DFS(ctx context.Context, reverse bool, fn GraphSearchFunc[T]) error
```

DFS performs a depth\-first search on the graph starting from the current node

<a name="GraphNode[T].Descendants"></a>
### func \(\*GraphNode\[T\]\) [Descendants](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L245>)

```go
func (n *GraphNode[T]) Descendants(fn func(node *GraphNode[T]) bool)
```

Descendants returns the descendants of the current node

<a name="GraphNode[T].EdgesFrom"></a>
### func \(\*GraphNode\[T\]\) [EdgesFrom](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L116>)

```go
func (n *GraphNode[T]) EdgesFrom(fn func(e *GraphEdge[T]) bool)
```

EdgesFrom returns the edges pointing from the current node

<a name="GraphNode[T].EdgesTo"></a>
### func \(\*GraphNode\[T\]\) [EdgesTo](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L125>)

```go
func (n *GraphNode[T]) EdgesTo(fn func(e *GraphEdge[T]) bool)
```

EdgesTo returns the edges pointing to the current node

<a name="GraphNode[T].Graph"></a>
### func \(\*GraphNode\[T\]\) [Graph](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L218>)

```go
func (n *GraphNode[T]) Graph() *DAG[T]
```

DirectedGraph returns the graph the node belongs to

<a name="GraphNode[T].ID"></a>
### func \(\*GraphNode\[T\]\) [ID](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L76>)

```go
func (n *GraphNode[T]) ID() string
```

ID returns the unique identifier of the node

<a name="GraphNode[T].IsConnectedTo"></a>
### func \(\*GraphNode\[T\]\) [IsConnectedTo](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L271>)

```go
func (n *GraphNode[T]) IsConnectedTo(node *GraphNode[T]) bool
```



<a name="GraphNode[T].Metadata"></a>
### func \(\*GraphNode\[T\]\) [Metadata](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L81>)

```go
func (n *GraphNode[T]) Metadata() map[string]string
```

Metadata returns the metadata of the node

<a name="GraphNode[T].Remove"></a>
### func \(\*GraphNode\[T\]\) [Remove](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L201>)

```go
func (n *GraphNode[T]) Remove() error
```

Remove removes the current node from the graph

<a name="GraphNode[T].RemoveEdge"></a>
### func \(\*GraphNode\[T\]\) [RemoveEdge](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L181>)

```go
func (n *GraphNode[T]) RemoveEdge(edgeID string)
```

RemoveEdge removes an edge from the current node by edgeID

<a name="GraphNode[T].SetEdge"></a>
### func \(\*GraphNode\[T\]\) [SetEdge](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L137>)

```go
func (n *GraphNode[T]) SetEdge(toNode *GraphNode[T], relationship string, metadata map[string]string) (*GraphEdge[T], error)
```

SetEdge sets an edge from the current node to the node with the given nodeID. If the nodeID does not exist, an error is returned. If the edgeID is empty, a unique id will be generated. If the metadata is nil, an empty map will be used.

<a name="GraphNode[T].SetID"></a>
### func \(\*GraphNode\[T\]\) [SetID](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L96>)

```go
func (n *GraphNode[T]) SetID(id string)
```

SetID sets the unique identifier of the node

<a name="GraphNode[T].SetMetadata"></a>
### func \(\*GraphNode\[T\]\) [SetMetadata](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L91>)

```go
func (n *GraphNode[T]) SetMetadata(metadata map[string]string)
```

SetMetadata sets the metadata of the node

<a name="GraphNode[T].SetValue"></a>
### func \(\*GraphNode\[T\]\) [SetValue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L101>)

```go
func (n *GraphNode[T]) SetValue(value T)
```

SetValue sets the value of the node

<a name="GraphNode[T].String"></a>
### func \(\*GraphNode\[T\]\) [String](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L267>)

```go
func (n *GraphNode[T]) String() string
```

String returns a string representation of the node

<a name="GraphNode[T].Value"></a>
### func \(\*GraphNode\[T\]\) [Value](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L86>)

```go
func (n *GraphNode[T]) Value() T
```

Value returns the value of the node

<a name="GraphSearchFunc"></a>
## type [GraphSearchFunc](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L439>)

GraphSearchFunc is a function that is called on each node in the graph during a search

```go
type GraphSearchFunc[T any] func(ctx context.Context, relationship string, node *GraphNode[T]) bool
```

<a name="HashMap"></a>
## type [HashMap](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L735-L738>)

HashMap is a thread safe map

```go
type HashMap[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewHashMap"></a>
### func [NewHashMap](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L727>)

```go
func NewHashMap[T any]() *HashMap[T]
```

NewHashMap creates a new generic hash map

<a name="HashMap[T].Clear"></a>
### func \(\*HashMap\[T\]\) [Clear](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L788>)

```go
func (n *HashMap[T]) Clear()
```

Clear clears the map

<a name="HashMap[T].Delete"></a>
### func \(\*HashMap\[T\]\) [Delete](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L773>)

```go
func (n *HashMap[T]) Delete(key string)
```

Delete deletes the key from the map

<a name="HashMap[T].Exists"></a>
### func \(\*HashMap\[T\]\) [Exists](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L780>)

```go
func (n *HashMap[T]) Exists(key string) bool
```

Exists returns true if the key exists in the map

<a name="HashMap[T].Get"></a>
### func \(\*HashMap\[T\]\) [Get](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L748>)

```go
func (n *HashMap[T]) Get(key string) (T, bool)
```

Get gets the value from the key

<a name="HashMap[T].Keys"></a>
### func \(\*HashMap\[T\]\) [Keys](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L795>)

```go
func (n *HashMap[T]) Keys() []string
```

Keys returns a copy of the keys in the map as a slice

<a name="HashMap[T].Len"></a>
### func \(\*HashMap\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L741>)

```go
func (n *HashMap[T]) Len() int
```

Len returns the length of the map

<a name="HashMap[T].Range"></a>
### func \(\*HashMap\[T\]\) [Range](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L763>)

```go
func (n *HashMap[T]) Range(f func(id string, node T) bool)
```

Range ranges over the map with a function until false is returned

<a name="HashMap[T].Set"></a>
### func \(\*HashMap\[T\]\) [Set](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L756>)

```go
func (n *HashMap[T]) Set(key string, value T)
```

Set sets the key to the value

<a name="HashMap[T].Values"></a>
### func \(\*HashMap\[T\]\) [Values](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L808>)

```go
func (n *HashMap[T]) Values() []T
```

Values returns a copy of the values in the map as a slice

<a name="MultiContext"></a>
## type [MultiContext](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1300-L1305>)

MultiContext is a context that can be used to combine contexts with a root context so they can be cancelled together.

```go
type MultiContext struct {
    context.Context
    // contains filtered or unexported fields
}
```

<a name="NewMultiContext"></a>
### func [NewMultiContext](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1308>)

```go
func NewMultiContext(ctx context.Context) *MultiContext
```

NewMultiContext returns a new MultiContext.

<a name="MultiContext.Cancel"></a>
### func \(\*MultiContext\) [Cancel](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1338>)

```go
func (m *MultiContext) Cancel()
```

Cancel cancels all child contexts.

<a name="MultiContext.WithContext"></a>
### func \(\*MultiContext\) [WithContext](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1329>)

```go
func (m *MultiContext) WithContext(ctx context.Context) context.Context
```

WithContext returns a new context that is a child of the root context. This context will be cancelled when the multi context is cancelled.

<a name="PriorityQueue"></a>
## type [PriorityQueue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L827-L830>)

PriorityQueue is a thread safe priority queue

```go
type PriorityQueue[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewPriorityQueue"></a>
### func [NewPriorityQueue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L833>)

```go
func NewPriorityQueue[T any]() *PriorityQueue[T]
```

NewPriorityQueue creates a new priority queue

<a name="PriorityQueue[T].Len"></a>
### func \(\*PriorityQueue\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L855>)

```go
func (q *PriorityQueue[T]) Len() int
```

Len returns the length of the queue

<a name="PriorityQueue[T].Peek"></a>
### func \(\*PriorityQueue\[T\]\) [Peek](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L884>)

```go
func (q *PriorityQueue[T]) Peek() (T, bool)
```

Peek returns the next item in the queue without removing it

<a name="PriorityQueue[T].Pop"></a>
### func \(\*PriorityQueue\[T\]\) [Pop](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L872>)

```go
func (q *PriorityQueue[T]) Pop() (T, bool)
```

Pop pops an item off the queue

<a name="PriorityQueue[T].Push"></a>
### func \(\*PriorityQueue\[T\]\) [Push](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L862>)

```go
func (q *PriorityQueue[T]) Push(item T, weight float64)
```

Push pushes an item onto the queue

<a name="PriorityQueue[T].UpdatePriority"></a>
### func \(\*PriorityQueue\[T\]\) [UpdatePriority](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L840>)

```go
func (q *PriorityQueue[T]) UpdatePriority(value T, priority float64)
```



<a name="Queue"></a>
## type [Queue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L969-L972>)

Queue is a thread safe non\-blocking queue

```go
type Queue[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewQueue"></a>
### func [NewQueue](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L975>)

```go
func NewQueue[T any]() *Queue[T]
```

NewQueue returns a new Queue

<a name="Queue[T].Len"></a>
### func \(\*Queue\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1002>)

```go
func (s *Queue[T]) Len() int
```

Len returns the length of the queue

<a name="Queue[T].Peek"></a>
### func \(\*Queue\[T\]\) [Peek](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1009>)

```go
func (s *Queue[T]) Peek() (T, bool)
```

Peek returns the next item in the queue without removing it

<a name="Queue[T].Pop"></a>
### func \(\*Queue\[T\]\) [Pop](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L988>)

```go
func (s *Queue[T]) Pop() (T, bool)
```

Pop and return top element of Queue. Return false if Queue is empty.

<a name="Queue[T].Push"></a>
### func \(\*Queue\[T\]\) [Push](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L981>)

```go
func (s *Queue[T]) Push(f T)
```

Push a new value onto the Queue

<a name="Queue[T].Range"></a>
### func \(\*Queue\[T\]\) [Range](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1019>)

```go
func (q *Queue[T]) Range(fn func(element T) bool)
```

Range executes a provided function once for each Queue element until it returns false or the Queue is empty.

<a name="Queue[T].RangeUntil"></a>
### func \(\*Queue\[T\]\) [RangeUntil](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1033>)

```go
func (q *Queue[T]) RangeUntil(fn func(element T) bool, done chan struct{})
```

RangeUntil executes a provided function once for each Queue element until it returns false or a value is sent on the done channel. Use this function when you want to continuously process items from the queue until a done signal is received.

<a name="Set"></a>
## type [Set](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1159-L1162>)

Set is a basic thread\-safe Set implementation.

```go
type Set[T comparable] struct {
    // contains filtered or unexported fields
}
```

<a name="NewSet"></a>
### func [NewSet](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1165>)

```go
func NewSet[T comparable]() *Set[T]
```

NewSet returns a new Set with the given initial size.

<a name="Set[T].Add"></a>
### func \(\*Set\[T\]\) [Add](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1171>)

```go
func (s *Set[T]) Add(val T)
```

Add adds an element to the Set.

<a name="Set[T].Contains"></a>
### func \(\*Set\[T\]\) [Contains](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1185>)

```go
func (s *Set[T]) Contains(val T) bool
```

Contains returns true if the Set contains the element.

<a name="Set[T].Len"></a>
### func \(\*Set\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1204>)

```go
func (s *Set[T]) Len() int
```

Len returns the number of elements in the Set.

<a name="Set[T].Range"></a>
### func \(\*Set\[T\]\) [Range](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1193>)

```go
func (s *Set[T]) Range(fn func(element T) bool)
```

Range executes a provided function once for each Set element until it returns false.

<a name="Set[T].Remove"></a>
### func \(\*Set\[T\]\) [Remove](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1178>)

```go
func (s *Set[T]) Remove(val T)
```

Remove removes an element from the Set.

<a name="Set[T].Sort"></a>
### func \(\*Set\[T\]\) [Sort](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1222>)

```go
func (s *Set[T]) Sort(lessFunc func(i T, j T) bool) []T
```

Sort returns the values of the set as an array sorted by the provided less function

<a name="Set[T].Values"></a>
### func \(\*Set\[T\]\) [Values](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1211>)

```go
func (s *Set[T]) Values() []T
```

Values returns the values of the set as an array

<a name="Stack"></a>
## type [Stack](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1057-L1060>)

Stack is a basic LIFO Stack

```go
type Stack[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewStack"></a>
### func [NewStack](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1051>)

```go
func NewStack[T any]() *Stack[T]
```

NewStack returns a new Stack instance

<a name="Stack[T].Clear"></a>
### func \(\*Stack\[T\]\) [Clear](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1103>)

```go
func (s *Stack[T]) Clear()
```

Clear removes all elements from the Stack

<a name="Stack[T].Len"></a>
### func \(\*Stack\[T\]\) [Len](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1139>)

```go
func (s *Stack[T]) Len() int
```

Len returns the number of elements in the Stack.

<a name="Stack[T].Peek"></a>
### func \(\*Stack\[T\]\) [Peek](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1146>)

```go
func (s *Stack[T]) Peek() (T, bool)
```

Peek returns the top element of the Stack without removing it. Return false if Stack is empty.

<a name="Stack[T].Pop"></a>
### func \(\*Stack\[T\]\) [Pop](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1089>)

```go
func (s *Stack[T]) Pop() (T, bool)
```

Pop removes and return top element of Stack. Return false if Stack is empty.

<a name="Stack[T].Push"></a>
### func \(\*Stack\[T\]\) [Push](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1082>)

```go
func (s *Stack[T]) Push(f T)
```

Push a new value onto the Stack \(LIFO\)

<a name="Stack[T].Range"></a>
### func \(\*Stack\[T\]\) [Range](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1110>)

```go
func (s *Stack[T]) Range(fn func(element T) bool)
```

Range executes a provided function once for each Stack element until it returns false.

<a name="Stack[T].RangeUntil"></a>
### func \(\*Stack\[T\]\) [RangeUntil](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1064>)

```go
func (s *Stack[T]) RangeUntil(fn func(element T) bool, done chan struct{})
```

RangeUntil executes a provided function once after calling Pop on the stack until the function returns false or a value is sent on the done channel. Use this function when you want to continuously process items from the stack until a done signal is received.

<a name="Stack[T].Sort"></a>
### func \(\*Stack\[T\]\) [Sort](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1130>)

```go
func (s *Stack[T]) Sort(lessFunc func(i T, j T) bool) []T
```

Sort returns the values of the stack as an array sorted by the provided less function

<a name="Stack[T].Values"></a>
### func \(\*Stack\[T\]\) [Values](<https://github.com/autom8ter/dagger/blob/main/dagger.go#L1123>)

```go
func (s *Stack[T]) Values() []T
```

Values returns the values of the stack as an array

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
